#!/usr/bin/env perl6

use MoarVM::Remote;
use JSON::Fast;

sub print-table(@chunks) {
    my $num-cols = [max] @chunks>>.value.map([max] *>>.elems).flat;
    if $num-cols == -Inf {
        say @chunks.perl;
        try say @chunks[0].key, ": empty.";
        return;
    }
    my @col-sizes = 0 xx $num-cols;
    for @chunks {
        for .value {
            @col-sizes >>[max]=>> $_>>.Str>>.chars;
        }
    }
    for @chunks -> $chunk {
        say "";
        say $chunk.key;
        for @($chunk.value) -> $line {
            print "    ";
            for @$line Z @col-sizes -> ($text, $fieldwidth) {
                print $text.&pad($fieldwidth + 2)
            }
            print "\n";
        }
    }
}

sub pad(Str() $str, $size) {
    my $result = " " x $size;
    $result.substr-rw(0..$str.chars) = $str;
    $result;
}

sub MAIN(Int $port) {
    my $remote = await MoarVM::Remote.connect($port);
    say "success!";

    $remote.events.tap({ say "Got event: "; .say });

    my @last-command-handles;

    sub format-attributes($lex-or-attr) {
        flat "concrete" xx ?$_<concrete>,
             "container" xx ?$_<container>,
             "value: {$_<value>//""}" xx ($_<value>:exists)
                 given $lex-or-attr;
    }

    sub format-lexicals-for-frame($lexicals) {
        gather for $lexicals.kv -> $n, $/ {
            my @attributes = format-attributes($/);

            @last-command-handles.push($<handle>.Int) with $<handle>;

            take $<handle> // "", $<type> || $<kind>, $n, @attributes.join(", ");
        }.sort(*.[0]).cache
    }

    while prompt("> ") -> $_ {
        when /:s execution / {
            say (await $remote.is-execution-suspended()) ?? "Execution suspended" !! "Execution not suspended";
        }
        when /:s sus[p[e[nd?]?]?]? (\d+)? / {
            say "trying to suspend thread $0" with $0;
            say "trying to suspend all threads" without $0;
            say await $remote.suspend($0 ?? $0.Int.self !! Whatever);
        }
        when /:s res[u[m[e?]?]?]? (\d+)? / {
            say "trying to resume thread $0" with $0;
            say "trying to resume all threads" without $0;
            say await $remote.resume($0 ?? $0.Int.self !! Whatever);
        }
        when /:s dump (\d+) / {
            my @frames = await $remote.dump($0.Int.self);
            my @table = "Stack trace of thread $0.Int()" => @frames.map({ (++$, .<name> || "<anon>", "$_.<file>:$_.<line>", .<bytecode_file> // "none") }).cache;
            print-table @table;
        }
        when / tl / {
            say (await $remote.threads-list).&to-json(:pretty);
        }
        when /:s ctxhandle (\d+) (\d+) / {
            say (await $remote.context-handle($0.Int.self, $1.Int.self)).&to-json(:pretty);
        }
        when /:s caller (\d+) / {
            my $result = await $remote.caller-context-handle($0.Int.self);
            say $result.&to-json(:pretty);
        }
        when /:s outer (\d+) / {
            my $result = $remote.outer-context-handle($0.Int.self);
            say $result.&to-json(:pretty);
        }
        when /:s coderef (\d+) (\d+) / {
            my $result = await $remote.coderef-handle($0.Int.self, $1.Int.self);
            say $result.&to-json(:pretty);
        }
        when /:s all lex[icals]? (\d+) / {
            # convenience: grab all lexicals on the stack
            my @allframes = (await $remote.dump($0.Int.self));
            my $framecount = +@allframes;

            @last-command-handles = Empty;

            my @chunks = gather for (^$framecount).reverse {
                my $handle = await $remote.context-handle($0.Int.self, $_);
                my $lexicals = (await $remote.lexicals($handle));

                @last-command-handles.push($handle);

                my $framedetails = "$_<name> ($_<file>:$_<line>)" given @allframes[$_];

                take "Frame {$_ + 1} - $framedetails - handle: $handle" =>
                        format-lexicals-for-frame($lexicals);
            };
            print-table(@chunks);
            say "";
            say "call 'release all' to free these @last-command-handles.elems() handles";
        }
        when /:s lexicals (\d+) / {
            @last-command-handles = Empty;

            my $result = await $remote.lexicals($0.Int.self);
            my @table = "Lexicals of handle $0.Int()" => format-lexicals-for-frame($result);
            print-table @table;
        }
        when /:s metadata (\d+) / {
            my $result = await $remote.object-metadata($0.Int.self);
            my @table = "Metadata of handle $0.Int()" =>
                gather {
                    my @features =
                        flat "positional"  xx ?$result<pos_features>,
                             "associative" xx ?$result<ass_features>,
                             "attributes"  xx ?$result<attr_features>;
                    take ["Features", @features.join(", ") || "none"];
                    take ["Size", ($result<size> // 0) ~ " + unmanaged: " ~ ($result<unmanaged_size> // 0)];
                    for $result.list.sort(*.key) {
                        next if .key eq any <pos_features ass_features attr_features size unmanaged_size>;
                        take [.key, .value // "-"];
                    }
                }.cache;
            print-table @table;
        }
        when /:s attributes (\d+) / {
            my $result = await $remote.attributes($0.Int.self);
            my %by-class = $result.categorize(*.<class>);
            my @table = gather for %by-class {
                take "From class $_.key()" =>
                    gather for @($_.value) {
                        my @attributes = format-attributes($_);

                        take (.<handle> // "", (.<kind> eq "obj" ?? .<type> !! .<kind>), .<name>, @attributes.join(", "))
                    }.cache;
                }.cache;
            say "Attributes for handle $0.Int()";
            print-table(@table);
        }
        when /:s positionals (\d+) / {
            my $result = await $remote.object-positionals($0.Int.self);
            my @table = "Positionals in handle $0.Int()" =>
                gather {
                    my $cnt = $result<start>;
                    if $result<kind> eq "obj" {
                        @last-command-handles = Empty;
                        for $result<contents>.list {
                            my @attributes = format-attributes($_);
                            @last-command-handles.push($_<handle>);
                            take [$cnt++, $_<handle>, $_<type>, @attributes.join(", ")];
                        }
                    } else {
                        for $result<contents>.list {
                            take [$cnt++, $_];
                        }
                    }
                }.cache;
            print-table(@table);
        }
        when /:s associatives (\d+) / {
            my $result = await $remote.object-associatives($0.Int.self);
            my @table = "Associatives in handle $0.Int()" =>
                gather {
                    if $result<kind> eq "obj" {
                        @last-command-handles = Empty;
                        for $result<contents>.list {
                            my @attributes = format-attributes(.value);
                            @last-command-handles.push(.value<handle>);
                            take [.value<handle>, .key, .value<type>, @attributes.join(", ")];
                        }
                    } else {
                        take ["NYI"];
                    }
                }.cache;
            print-table(@table);
        }
        when /:s clearbp \"(.*?)\" (\d+) / {
            my $result = await $remote.clear-breakpoints($0.Str, $1.Int);
            say $result.&to-json(:pretty);
        }
        when /:s [breakpoint|bp] \"(.*?)\" (\d+) (\d?) (\d?) / {
            my $result = await $remote.breakpoint($0.Str, $1.Int, suspend => so ($2 && $2.Int), stacktrace => so ($3 && $3.Int));
            say $result.&to-json(:pretty);
        }
        when /:s release[handles]? (\d+)+ % \s+/ {
            my $result = await $remote.release-handles($0>>.Int);
            say $result.&to-json(:pretty);
        }
        when /:s release all [handles]? [keep (\d+)+ % \s+]?/ {
            my @free = (@last-command-handles (-) $0.List>>.Int).keys;
            say "releasing @free.elems() handles{ " keeping $0.List.elems()" if $0 }";
            my $result = await $remote.release-handles(@free);
            @last-command-handles = Empty;
        }
        when /:s debug (on|off)/ {
            $remote.debug = $0.Str eq "on";
        }
        default {
            say "oh no! don't know what to do with $_\n" if $_;

            say q:to/CMDS/;
                Supported commands:

                dump [thread number]
                    Print a stacktrace for the given thread.

                suspend [thread number]
                resume  [thread number]
                    Suspend or resume a thread, or all thread if no thread number is passed.

                tl
                    Output a list of all threads and their status.

                ctxhandle [thread number] [frame number]
                    Retrieve a handle for a frame (MVMContext) on the thread's stack.

                caller [handle (MVMContext)]
                    Retrieve a handle for a frame's caller frame (MVMContext)

                outer [handle (MVMContext)]
                    Retrieve a handle for a frame's outer frame (MVMContext)

                coderef [thread number] [frame number]
                    Retrieve a handle for the code object (MVMCode) for a frame on a thread's stack.

                lexicals [handle (MVMContext)]
                    Retrieve a list of lexicals and handlers for any object lexicals for a given frame.

                metadata [handle (MVMObject)]
                    Retrieve a bunch of metadata about an object.

                attributes [handle (MVMObject)]
                    Retrieve a list of all attributes an object has, along with handles for any object values.

                positionals [handle (MVMObject)]
                    Retrieve the contents of an object that has positional properties, like an array.

                release [handle handle ...]
                    Releases handles, so the corresponding objects can be garbage collected.

                release all [keep [handle handle ...]]
                    Release all handles allocated by the previous command, optionally keeping
                    the specified handles for further use.

                [breakpoint|bp] "[file path]" [line number] [suspend on hit]? [send stacktrace on hit]? /
                    Sets a breakpoint for a given filename and line number.
                    If suspend is 1, execution of the thread that hit it will stop.
                    If the stacktrace is requested, every hit will send a stack trace along with it.

                clearbp "[file path]" [line number]
                    Clear any breakpoints for a given filename and line number.

                debug [on|off]
                    Output debugging information.
                CMDS
        }
        CATCH {
            default {
                .say;
            }
        }
    }
}
