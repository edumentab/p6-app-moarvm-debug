#!/usr/bin/env perl6

use MoarVM::Remote;
use JSON::Fast;


sub MAIN(Int $port) {
    my $remote = await MoarVM::Remote.connect($port);
    say "success!";

    $remote.events.tap({ say "Got event: "; .say });

    while prompt("> ") -> $_ {
        when /:s execution / {
            say (await $remote.is-execution-suspended()) ?? "Execution suspended" !! "Execution not suspended";
        }
        when /:s sus[p[e[nd?]?]?]? (\d+)? / {
            say "trying to suspend thread $0";
            say await $remote.suspend($0 ?? $0.Int.self !! Whatever);
        }
        when /:s res[u[m[e?]?]?]? (\d+)? / {
            say "trying to resume thread $0" with $0;
            say "trying to resume all threads" without $0;
            say await $remote.resume($0 ?? $0.Int.self !! Whatever);
        }
        when /:s dump (\d+) / {
            say (await $remote.dump($0.Int.self)).&to-json(:pretty);
        }
        when / tl / {
            say (await $remote.threads-list).&to-json(:pretty);
        }
        when /:s ctxhandle (\d+) (\d+) / {
            say (await $remote.context-handle($0.Int.self, $1.Int.self)).&to-json(:pretty);
        }
        when /:s caller (\d+) / {
            my $result = await $remote.caller-context-handle($0.Int.self);
            say $result.&to-json(:pretty);
        }
        when /:s outer (\d+) / {
            my $result = $remote.outer-context-handle($0.Int.self);
            say $result.&to-json(:pretty);
        }
        when /:s coderef (\d+) (\d+) / {
            my $result = await $remote.coderef-handle($0.Int.self, $1.Int.self);
            say $result.&to-json(:pretty);
        }
        when /:s lexicals (\d+) / {
            my $result = await $remote.lexicals($0.Int.self);
            say $result.&to-json(:pretty);
        }
        when /:s attributes (\d+) / {
            my $result = await $remote.attributes($0.Int.self);
            say $result.&to-json(:pretty);
        }
        when /:s clearbp \"(.*?)\" (\d+) / {
            my $result = await $remote.clear-breakpoints($0.Str, $1.Int);
            say $result.&to-json(:pretty);
        }
        when /:s [breakpoint|bp] \"(.*?)\" (\d+) (\d?) (\d?) / {
            my $result = await $remote.breakpoint($0.Str, $1.Int, suspend => so ($2 && $2.Int), stacktrace => so ($3 && $3.Int));
            say $result.&to-json(:pretty);
        }
        default {
            say "oh no! don't know what to do with $_";

            say "supported commands:";
            say q:to/CMDS/;
                /:s sus[p[e[nd?]?]?]? (\d+)? /
                /:s res[u[m[e?]?]?]? (\d+)? /
                /:s dump (\d+) /
                / tl /
                /:s ctxhandle (\d+) (\d+) /
                /:s caller (\d+) /
                /:s outer (\d+) /
                /:s coderef (\d+) (\d+) /
                /:s lexicals (\d+) /
                /:s attributes (\d+) /
                /:s [breakpoint|bp] \"(.*?)\" (\d+) (\d?) (\d?) /
                /:s clearbp \"(.*?)\" (\d+) /
                CMDS
        }
        CATCH {
            default {
                .say;
            }
        }
    }
}
